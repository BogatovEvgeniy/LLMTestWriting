// Example 1: Edge Case Handling
class StringProcessor:
    def truncate(self, text: str, max_length: int) -> str:
        """
        Truncates the given text to the specified maximum length.
        If truncation occurs, adds '...' at the end.

        Args:
            text: Input string to truncate
            max_length: Maximum allowed length including ellipsis

        Returns:
            Truncated string with ellipsis if needed

        Raises:
            ValueError: If max_length is less than 3
        """
        if max_length < 3:
            raise ValueError("Maximum length must be at least 3 to accommodate ellipsis")

        if len(text) <= max_length:
            return text

        return text[:max_length-3] + "..."

# Example 2: State Management
class ShoppingCart:
    def __init__(self):
        self.items = {}
        self.is_locked = False

    def add_item(self, item_id: str, quantity: int) -> bool:
        """
        Adds an item to the cart if it's not locked.

        Args:
            item_id: Unique identifier for the item
            quantity: Number of items to add (must be positive)

        Returns:
            bool: True if item was added successfully, False if cart is locked

        Raises:
            ValueError: If quantity is not positive
        """
        if self.is_locked:
            return False

        if quantity <= 0:
            raise ValueError("Quantity must be positive")

        if item_id in self.items:
            self.items[item_id] += quantity
        else:
            self.items[item_id] = quantity
        return True

    def lock(self):
        """Locks the cart preventing further modifications."""
        self.is_locked = True

# Example 3: Complex Data Transformation
class DataNormalizer:
    def normalize_matrix(self, matrix: list) -> list:
        """
        Normalizes a 2D matrix by:
        1. Replacing None values with 0
        2. Scaling each row to sum to 1
        3. Transposing the matrix

        Args:
            matrix: 2D list of numbers (can contain None)

        Returns:
            Normalized and transposed matrix

        Raises:
            ValueError: If matrix is empty or not rectangular
        """
        if not matrix or not matrix[0]:
            raise ValueError("Matrix cannot be empty")

        # Check if matrix is rectangular
        row_length = len(matrix[0])
        if not all(len(row) == row_length for row in matrix):
            raise ValueError("All rows must have same length")

        # Replace None with 0
        processed = [[0 if val is None else val for val in row] for row in matrix]

        # Scale rows to sum to 1
        normalized = []
        for row in processed:
            row_sum = sum(row)
            if row_sum == 0:
                normalized.append([0] * len(row))
            else:
                normalized.append([val/row_sum for val in row])

        # Transpose
        return [[normalized[j][i] for j in range(len(normalized))]
                for i in range(len(normalized[0]))]

# Example 4: Async Operations
import asyncio
from typing import List, Dict

class AsyncDataFetcher:
    def __init__(self):
        self.cache = {}

    async def fetch_data(self, ids: List[str]) -> Dict[str, str]:
        """
        Simulates fetching data for multiple IDs asynchronously.
        Uses caching to avoid re-fetching.

        Args:
            ids: List of IDs to fetch data for

        Returns:
            Dictionary mapping IDs to fetched data
        """
        results = {}
        async def fetch_single(id_: str):
            if id_ in self.cache:
                results[id_] = self.cache[id_]
                return

            # Simulate network delay
            await asyncio.sleep(0.1)
            data = f"Data_{id_}"
            self.cache[id_] = data
            results[id_] = data

        await asyncio.gather(*[fetch_single(id_) for id_ in ids])
        return results

# Example 5: Inheritance and Polymorphism
from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def area(self) -> float:
        pass

    @abstractmethod
    def perimeter(self) -> float:
        pass

class Circle(Shape):
    def __init__(self, radius: float):
        if radius <= 0:
            raise ValueError("Radius must be positive")
        self.radius = radius

    def area(self) -> float:
        return math.pi * self.radius ** 2

    def perimeter(self) -> float:
        return 2 * math.pi * self.radius

class Rectangle(Shape):
    def __init__(self, width: float, height: float):
        if width <= 0 or height <= 0:
            raise ValueError("Dimensions must be positive")
        self.width = width
        self.height = height

    def area(self) -> float:
        return self.width * self.height

    def perimeter(self) -> float:
        return 2 * (self.width + self.height)